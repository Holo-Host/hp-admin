{"ast":null,"code":"/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _assertArgs = _interopRequireDefault(require(\"assert-args\"));\n\nvar _eventemitter = _interopRequireDefault(require(\"eventemitter3\"));\n\nvar _circularJson = _interopRequireDefault(require(\"circular-json\"));\n\nvar _default = function _default(WebSocket) {\n  return (\n    /*#__PURE__*/\n    function (_EventEmitter) {\n      (0, _inherits2[\"default\"])(Client, _EventEmitter);\n      /**\n       * Instantiate a Client class.\n       * @constructor\n       * @param {String} address - url to a websocket server\n       * @param {Object} options - ws options object with reconnect parameters\n       * @param {Function} generate_request_id - custom generation request Id\n       * @return {Client}\n       */\n\n      function Client() {\n        var _this;\n\n        var address = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"ws://localhost:8080\";\n\n        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n            _ref$autoconnect = _ref.autoconnect,\n            autoconnect = _ref$autoconnect === void 0 ? true : _ref$autoconnect,\n            _ref$reconnect = _ref.reconnect,\n            reconnect = _ref$reconnect === void 0 ? true : _ref$reconnect,\n            _ref$reconnect_interv = _ref.reconnect_interval,\n            reconnect_interval = _ref$reconnect_interv === void 0 ? 1000 : _ref$reconnect_interv,\n            _ref$max_reconnects = _ref.max_reconnects,\n            max_reconnects = _ref$max_reconnects === void 0 ? 5 : _ref$max_reconnects;\n\n        var generate_request_id = arguments.length > 2 ? arguments[2] : undefined;\n        (0, _classCallCheck2[\"default\"])(this, Client);\n        _this = (0, _possibleConstructorReturn2[\"default\"])(this, (0, _getPrototypeOf2[\"default\"])(Client).call(this));\n        _this.queue = {};\n        _this.rpc_id = 0;\n        _this.address = address;\n        _this.options = arguments[1];\n        _this.autoconnect = autoconnect;\n        _this.ready = false;\n        _this.reconnect = reconnect;\n        _this.reconnect_interval = reconnect_interval;\n        _this.max_reconnects = max_reconnects;\n        _this.current_reconnects = 0;\n\n        _this.generate_request_id = generate_request_id || function () {\n          return ++_this.rpc_id;\n        };\n\n        if (_this.autoconnect) _this._connect(_this.address, _this.options);\n        return _this;\n      }\n      /**\n       * Connects to a defined server if not connected already.\n       * @method\n       * @return {Undefined}\n       */\n\n\n      (0, _createClass2[\"default\"])(Client, [{\n        key: \"connect\",\n        value: function connect() {\n          if (this.socket) return;\n\n          this._connect(this.address, this.options);\n        }\n        /**\n         * Calls a registered RPC method on server.\n         * @method\n         * @param {String} method - RPC method name\n         * @param {Object|Array} params - optional method parameters\n         * @param {Number} timeout - RPC reply timeout value\n         * @param {Object} ws_opts - options passed to ws\n         * @return {Promise}\n         */\n\n      }, {\n        key: \"call\",\n        value: function call(method, params, timeout, ws_opts) {\n          var _this2 = this;\n\n          (0, _assertArgs[\"default\"])(arguments, {\n            \"method\": \"string\",\n            \"[params]\": [\"object\", Array],\n            \"[timeout]\": \"number\",\n            \"[ws_opts]\": \"object\"\n          });\n\n          if (!ws_opts && \"object\" === (0, _typeof2[\"default\"])(timeout)) {\n            ws_opts = timeout;\n            timeout = null;\n          }\n\n          return new Promise(function (resolve, reject) {\n            if (!_this2.ready) return reject(new Error(\"socket not ready\"));\n\n            var rpc_id = _this2.generate_request_id(method, params);\n\n            var message = {\n              jsonrpc: \"2.0\",\n              method: method,\n              params: params || null,\n              id: rpc_id\n            };\n\n            _this2.socket.send(JSON.stringify(message), ws_opts, function (error) {\n              if (error) return reject(error);\n              _this2.queue[rpc_id] = {\n                promise: [resolve, reject]\n              };\n\n              if (timeout) {\n                _this2.queue[rpc_id].timeout = setTimeout(function () {\n                  _this2.queue[rpc_id] = null;\n                  reject(new Error(\"reply timeout\"));\n                }, timeout);\n              }\n            });\n          });\n        }\n        /**\n         * Logins with the other side of the connection.\n         * @method\n         * @param {Object} params - Login credentials object\n         * @return {Promise}\n         */\n\n      }, {\n        key: \"login\",\n        value: function () {\n          var _login = (0, _asyncToGenerator2[\"default\"])(\n          /*#__PURE__*/\n          _regenerator[\"default\"].mark(function _callee(params) {\n            return _regenerator[\"default\"].wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.next = 2;\n                    return this.call(\"rpc.login\", params);\n\n                  case 2:\n                    return _context.abrupt(\"return\", _context.sent);\n\n                  case 3:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, this);\n          }));\n\n          function login(_x) {\n            return _login.apply(this, arguments);\n          }\n\n          return login;\n        }()\n        /**\n         * Fetches a list of client's methods registered on server.\n         * @method\n         * @return {Array}\n         */\n\n      }, {\n        key: \"listMethods\",\n        value: function () {\n          var _listMethods = (0, _asyncToGenerator2[\"default\"])(\n          /*#__PURE__*/\n          _regenerator[\"default\"].mark(function _callee2() {\n            return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    _context2.next = 2;\n                    return this.call(\"__listMethods\");\n\n                  case 2:\n                    return _context2.abrupt(\"return\", _context2.sent);\n\n                  case 3:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2, this);\n          }));\n\n          function listMethods() {\n            return _listMethods.apply(this, arguments);\n          }\n\n          return listMethods;\n        }()\n        /**\n         * Sends a JSON-RPC 2.0 notification to server.\n         * @method\n         * @param {String} method - RPC method name\n         * @param {Object} params - optional method parameters\n         * @return {Promise}\n         */\n\n      }, {\n        key: \"notify\",\n        value: function notify(method, params) {\n          var _this3 = this;\n\n          (0, _assertArgs[\"default\"])(arguments, {\n            \"method\": \"string\",\n            \"[params]\": [\"object\", Array]\n          });\n          return new Promise(function (resolve, reject) {\n            if (!_this3.ready) return reject(new Error(\"socket not ready\"));\n            var message = {\n              jsonrpc: \"2.0\",\n              method: method,\n              params: params || null\n            };\n\n            _this3.socket.send(JSON.stringify(message), function (error) {\n              if (error) return reject(error);\n              resolve();\n            });\n          });\n        }\n        /**\n         * Subscribes for a defined event.\n         * @method\n         * @param {String|Array} event - event name\n         * @return {Undefined}\n         * @throws {Error}\n         */\n\n      }, {\n        key: \"subscribe\",\n        value: function () {\n          var _subscribe = (0, _asyncToGenerator2[\"default\"])(\n          /*#__PURE__*/\n          _regenerator[\"default\"].mark(function _callee3(event) {\n            var result,\n                _args3 = arguments;\n            return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n              while (1) {\n                switch (_context3.prev = _context3.next) {\n                  case 0:\n                    (0, _assertArgs[\"default\"])(_args3, {\n                      event: [\"string\", Array]\n                    });\n                    if (typeof event === \"string\") event = [event];\n                    _context3.next = 4;\n                    return this.call(\"rpc.on\", event);\n\n                  case 4:\n                    result = _context3.sent;\n\n                    if (!(typeof event === \"string\" && result[event] !== \"ok\")) {\n                      _context3.next = 7;\n                      break;\n                    }\n\n                    throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n\n                  case 7:\n                    return _context3.abrupt(\"return\", result);\n\n                  case 8:\n                  case \"end\":\n                    return _context3.stop();\n                }\n              }\n            }, _callee3, this);\n          }));\n\n          function subscribe(_x2) {\n            return _subscribe.apply(this, arguments);\n          }\n\n          return subscribe;\n        }()\n        /**\n         * Unsubscribes from a defined event.\n         * @method\n         * @param {String} event - event name\n         * @return {Undefined}\n         * @throws {Error}\n         */\n\n      }, {\n        key: \"unsubscribe\",\n        value: function () {\n          var _unsubscribe = (0, _asyncToGenerator2[\"default\"])(\n          /*#__PURE__*/\n          _regenerator[\"default\"].mark(function _callee4(event) {\n            var result,\n                _args4 = arguments;\n            return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n              while (1) {\n                switch (_context4.prev = _context4.next) {\n                  case 0:\n                    (0, _assertArgs[\"default\"])(_args4, {\n                      event: [\"string\", Array]\n                    });\n                    if (typeof event === \"string\") event = [event];\n                    _context4.next = 4;\n                    return this.call(\"rpc.off\", event);\n\n                  case 4:\n                    result = _context4.sent;\n\n                    if (!(typeof event === \"string\" && result[event] !== \"ok\")) {\n                      _context4.next = 7;\n                      break;\n                    }\n\n                    throw new Error(\"Failed unsubscribing from an event with: \" + result);\n\n                  case 7:\n                    return _context4.abrupt(\"return\", result);\n\n                  case 8:\n                  case \"end\":\n                    return _context4.stop();\n                }\n              }\n            }, _callee4, this);\n          }));\n\n          function unsubscribe(_x3) {\n            return _unsubscribe.apply(this, arguments);\n          }\n\n          return unsubscribe;\n        }()\n        /**\n         * Closes a WebSocket connection gracefully.\n         * @method\n         * @param {Number} code - socket close code\n         * @param {String} data - optional data to be sent before closing\n         * @return {Undefined}\n         */\n\n      }, {\n        key: \"close\",\n        value: function close(code, data) {\n          this.socket.close(code || 1000, data);\n        }\n        /**\n         * Connection/Message handler.\n         * @method\n         * @private\n         * @param {String} address - WebSocket API address\n         * @param {Object} options - ws options object\n         * @return {Undefined}\n         */\n\n      }, {\n        key: \"_connect\",\n        value: function _connect(address, options) {\n          var _this4 = this;\n\n          this.socket = new WebSocket(address, options);\n          this.socket.on(\"open\", function () {\n            _this4.ready = true;\n\n            _this4.emit(\"open\");\n\n            _this4.current_reconnects = 0;\n          });\n          this.socket.on(\"message\", function (message) {\n            if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n\n            try {\n              message = _circularJson[\"default\"].parse(message);\n            } catch (error) {\n              return;\n            } // check if any listeners are attached and forward event\n\n\n            if (message.notification && _this4.listeners(message.notification).length) {\n              if (!Object.keys(message.params).length) return _this4.emit(message.notification);\n              var args = [message.notification];\n              if (message.params.constructor === Object) args.push(message.params);else // using for-loop instead of unshift/spread because performance is better\n                for (var i = 0; i < message.params.length; i++) {\n                  args.push(message.params[i]);\n                }\n              return _this4.emit.apply(_this4, args);\n            }\n\n            if (!_this4.queue[message.id]) {\n              // general JSON RPC 2.0 events\n              if (message.method && message.params) return _this4.emit(message.method, message.params);else return;\n            }\n\n            if (_this4.queue[message.id].timeout) clearTimeout(_this4.queue[message.id].timeout);\n            if (message.error) _this4.queue[message.id].promise[1](message.error);else _this4.queue[message.id].promise[0](message.result);\n            _this4.queue[message.id] = null;\n          });\n          this.socket.on(\"error\", function (error) {\n            return _this4.emit(\"error\", error);\n          });\n          this.socket.on(\"close\", function (code, message) {\n            if (_this4.ready) _this4.emit(\"close\", code, message);\n            _this4.ready = false;\n            if (code === 1000) return;\n            _this4.current_reconnects++;\n            if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0)) setTimeout(function () {\n              return _this4._connect(address, options);\n            }, _this4.reconnect_interval);\n          });\n        }\n      }]);\n      return Client;\n    }(_eventemitter[\"default\"])\n  );\n};\n\nexports[\"default\"] = _default;","map":null,"metadata":{},"sourceType":"script"}