{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar implementsAbstractType_1 = require(\"../implementsAbstractType\");\n\nvar ExpandAbstractTypes =\n/** @class */\nfunction () {\n  function ExpandAbstractTypes(transformedSchema, targetSchema) {\n    this.targetSchema = targetSchema;\n    this.mapping = extractPossibleTypes(transformedSchema, targetSchema);\n    this.reverseMapping = flipMapping(this.mapping);\n  }\n\n  ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {\n    var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);\n    return __assign({}, originalRequest, {\n      document: document\n    });\n  };\n\n  return ExpandAbstractTypes;\n}();\n\nexports.default = ExpandAbstractTypes;\n\nfunction extractPossibleTypes(transformedSchema, targetSchema) {\n  var typeMap = transformedSchema.getTypeMap();\n  var mapping = {};\n  Object.keys(typeMap).forEach(function (typeName) {\n    var type = typeMap[typeName];\n\n    if (graphql_1.isAbstractType(type)) {\n      var targetType = targetSchema.getType(typeName);\n\n      if (!graphql_1.isAbstractType(targetType)) {\n        var implementations = transformedSchema.getPossibleTypes(type) || [];\n        mapping[typeName] = implementations.filter(function (impl) {\n          return targetSchema.getType(impl.name);\n        }).map(function (impl) {\n          return impl.name;\n        });\n      }\n    }\n  });\n  return mapping;\n}\n\nfunction flipMapping(mapping) {\n  var result = {};\n  Object.keys(mapping).forEach(function (typeName) {\n    var toTypeNames = mapping[typeName];\n    toTypeNames.forEach(function (toTypeName) {\n      if (!result[toTypeName]) {\n        result[toTypeName] = [];\n      }\n\n      result[toTypeName].push(typeName);\n    });\n  });\n  return result;\n}\n\nfunction expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {\n  var _a;\n\n  var operations = document.definitions.filter(function (def) {\n    return def.kind === graphql_1.Kind.OPERATION_DEFINITION;\n  });\n  var fragments = document.definitions.filter(function (def) {\n    return def.kind === graphql_1.Kind.FRAGMENT_DEFINITION;\n  });\n  var existingFragmentNames = fragments.map(function (fragment) {\n    return fragment.name.value;\n  });\n  var fragmentCounter = 0;\n\n  var generateFragmentName = function (typeName) {\n    var fragmentName;\n\n    do {\n      fragmentName = \"_\" + typeName + \"_Fragment\" + fragmentCounter;\n      fragmentCounter++;\n    } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n\n    return fragmentName;\n  };\n\n  var newFragments = [];\n  var fragmentReplacements = {};\n  fragments.forEach(function (fragment) {\n    newFragments.push(fragment);\n    var possibleTypes = mapping[fragment.typeCondition.name.value];\n\n    if (possibleTypes) {\n      fragmentReplacements[fragment.name.value] = [];\n      possibleTypes.forEach(function (possibleTypeName) {\n        var name = generateFragmentName(possibleTypeName);\n        existingFragmentNames.push(name);\n        var newFragment = {\n          kind: graphql_1.Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: graphql_1.Kind.NAME,\n            value: name\n          },\n          typeCondition: {\n            kind: graphql_1.Kind.NAMED_TYPE,\n            name: {\n              kind: graphql_1.Kind.NAME,\n              value: possibleTypeName\n            }\n          },\n          selectionSet: fragment.selectionSet\n        };\n        newFragments.push(newFragment);\n        fragmentReplacements[fragment.name.value].push({\n          fragmentName: name,\n          typeName: possibleTypeName\n        });\n      });\n    }\n  });\n\n  var newDocument = __assign({}, document, {\n    definitions: operations.concat(newFragments)\n  });\n\n  var typeInfo = new graphql_1.TypeInfo(targetSchema);\n  return graphql_1.visit(newDocument, graphql_1.visitWithTypeInfo(typeInfo, (_a = {}, _a[graphql_1.Kind.SELECTION_SET] = function (node) {\n    var newSelections = node.selections.slice();\n    var parentType = graphql_1.getNamedType(typeInfo.getParentType());\n    node.selections.forEach(function (selection) {\n      if (selection.kind === graphql_1.Kind.INLINE_FRAGMENT) {\n        var possibleTypes = mapping[selection.typeCondition.name.value];\n\n        if (possibleTypes) {\n          possibleTypes.forEach(function (possibleType) {\n            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(possibleType))) {\n              newSelections.push({\n                kind: graphql_1.Kind.INLINE_FRAGMENT,\n                typeCondition: {\n                  kind: graphql_1.Kind.NAMED_TYPE,\n                  name: {\n                    kind: graphql_1.Kind.NAME,\n                    value: possibleType\n                  }\n                },\n                selectionSet: selection.selectionSet\n              });\n            }\n          });\n        }\n      } else if (selection.kind === graphql_1.Kind.FRAGMENT_SPREAD) {\n        var fragmentName = selection.name.value;\n        var replacements = fragmentReplacements[fragmentName];\n\n        if (replacements) {\n          replacements.forEach(function (replacement) {\n            var typeName = replacement.typeName;\n\n            if (implementsAbstractType_1.default(targetSchema, parentType, targetSchema.getType(typeName))) {\n              newSelections.push({\n                kind: graphql_1.Kind.FRAGMENT_SPREAD,\n                name: {\n                  kind: graphql_1.Kind.NAME,\n                  value: replacement.fragmentName\n                }\n              });\n            }\n          });\n        }\n      }\n    });\n\n    if (parentType && reverseMapping[parentType.name]) {\n      newSelections.push({\n        kind: graphql_1.Kind.FIELD,\n        name: {\n          kind: graphql_1.Kind.NAME,\n          value: '__typename'\n        }\n      });\n    }\n\n    if (newSelections.length !== node.selections.length) {\n      return __assign({}, node, {\n        selections: newSelections\n      });\n    }\n  }, _a)));\n}","map":null,"metadata":{},"sourceType":"script"}