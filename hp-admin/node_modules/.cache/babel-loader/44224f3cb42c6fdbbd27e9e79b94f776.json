{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar graphql_1 = require(\"graphql\");\n\nvar values_1 = require(\"graphql/execution/values\");\n\nvar hasOwn = Object.prototype.hasOwnProperty; // Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\n\nvar SchemaVisitor =\n/** @class */\nfunction () {\n  function SchemaVisitor() {} // Determine if this SchemaVisitor (sub)class implements a particular\n  // visitor method.\n\n\n  SchemaVisitor.implementsVisitorMethod = function (methodName) {\n    if (!methodName.startsWith('visit')) {\n      return false;\n    }\n\n    var method = this.prototype[methodName];\n\n    if (typeof method !== 'function') {\n      return false;\n    }\n\n    if (this === SchemaVisitor) {\n      // The SchemaVisitor class implements every visitor method.\n      return true;\n    }\n\n    var stub = SchemaVisitor.prototype[methodName];\n\n    if (method === stub) {\n      // If this.prototype[methodName] was just inherited from SchemaVisitor,\n      // then this class does not really implement the method.\n      return false;\n    }\n\n    return true;\n  }; // Concrete subclasses of SchemaVisitor should override one or more of these\n  // visitor methods, in order to express their interest in handling certain\n  // schema types/locations. Each method may return null to remove the given\n  // type from the schema, a non-null value of the same type to update the\n  // type in the schema, or nothing to leave the type as it was.\n\n  /* tslint:disable:no-empty */\n\n\n  SchemaVisitor.prototype.visitSchema = function (schema) {};\n\n  SchemaVisitor.prototype.visitScalar = function (scalar) {};\n\n  SchemaVisitor.prototype.visitObject = function (object) {};\n\n  SchemaVisitor.prototype.visitFieldDefinition = function (field, details) {};\n\n  SchemaVisitor.prototype.visitArgumentDefinition = function (argument, details) {};\n\n  SchemaVisitor.prototype.visitInterface = function (iface) {};\n\n  SchemaVisitor.prototype.visitUnion = function (union) {};\n\n  SchemaVisitor.prototype.visitEnum = function (type) {};\n\n  SchemaVisitor.prototype.visitEnumValue = function (value, details) {};\n\n  SchemaVisitor.prototype.visitInputObject = function (object) {};\n\n  SchemaVisitor.prototype.visitInputFieldDefinition = function (field, details) {};\n\n  return SchemaVisitor;\n}();\n\nexports.SchemaVisitor = SchemaVisitor; // Generic function for visiting GraphQLSchema objects.\n\nfunction visitSchema(schema, // To accommodate as many different visitor patterns as possible, the\n// visitSchema function does not simply accept a single instance of the\n// SchemaVisitor class, but instead accepts a function that takes the\n// current VisitableSchemaType object and the name of a visitor method and\n// returns an array of SchemaVisitor instances that implement the visitor\n// method and have an interest in handling the given VisitableSchemaType\n// object. In the simplest case, this function can always return an array\n// containing a single visitor object, without even looking at the type or\n// methodName parameters. In other cases, this function might sometimes\n// return an empty array to indicate there are no visitors that should be\n// applied to the given VisitableSchemaType object. For an example of a\n// visitor pattern that benefits from this abstraction, see the\n// SchemaDirectiveVisitor class below.\nvisitorSelector) {\n  // Helper function that calls visitorSelector and applies the resulting\n  // visitors to the given type, with arguments [type, ...args].\n  function callMethod(methodName, type) {\n    var args = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n\n    visitorSelector(type, methodName).every(function (visitor) {\n      var newType = visitor[methodName].apply(visitor, [type].concat(args));\n\n      if (typeof newType === 'undefined') {\n        // Keep going without modifying type.\n        return true;\n      }\n\n      if (methodName === 'visitSchema' || type instanceof graphql_1.GraphQLSchema) {\n        throw new Error(\"Method \" + methodName + \" cannot replace schema with \" + newType);\n      }\n\n      if (newType === null) {\n        // Stop the loop and return null form callMethod, which will cause\n        // the type to be removed from the schema.\n        type = null;\n        return false;\n      } // Update type to the new type returned by the visitor method, so that\n      // later directives will see the new type, and callMethod will return\n      // the final type.\n\n\n      type = newType;\n      return true;\n    }); // If there were no directives for this type object, or if all visitor\n    // methods returned nothing, type will be returned unmodified.\n\n    return type;\n  } // Recursive helper function that calls any appropriate visitor methods for\n  // each object in the schema, then traverses the object's children (if any).\n\n\n  function visit(type) {\n    if (type instanceof graphql_1.GraphQLSchema) {\n      // Unlike the other types, the root GraphQLSchema object cannot be\n      // replaced by visitor methods, because that would make life very hard\n      // for SchemaVisitor subclasses that rely on the original schema object.\n      callMethod('visitSchema', type);\n      updateEachKey(type.getTypeMap(), function (namedType, typeName) {\n        if (!typeName.startsWith('__')) {\n          // Call visit recursively to let it determine which concrete\n          // subclass of GraphQLNamedType we found in the type map. Because\n          // we're using updateEachKey, the result of visit(namedType) may\n          // cause the type to be removed or replaced.\n          return visit(namedType);\n        }\n      });\n      return type;\n    }\n\n    if (type instanceof graphql_1.GraphQLObjectType) {\n      // Note that callMethod('visitObject', type) may not actually call any\n      // methods, if there are no @directive annotations associated with this\n      // type, or if this SchemaDirectiveVisitor subclass does not override\n      // the visitObject method.\n      var newObject = callMethod('visitObject', type);\n\n      if (newObject) {\n        visitFields(newObject);\n      }\n\n      return newObject;\n    }\n\n    if (type instanceof graphql_1.GraphQLInterfaceType) {\n      var newInterface = callMethod('visitInterface', type);\n\n      if (newInterface) {\n        visitFields(newInterface);\n      }\n\n      return newInterface;\n    }\n\n    if (type instanceof graphql_1.GraphQLInputObjectType) {\n      var newInputObject_1 = callMethod('visitInputObject', type);\n\n      if (newInputObject_1) {\n        updateEachKey(newInputObject_1.getFields(), function (field) {\n          // Since we call a different method for input object fields, we\n          // can't reuse the visitFields function here.\n          return callMethod('visitInputFieldDefinition', field, {\n            objectType: newInputObject_1\n          });\n        });\n      }\n\n      return newInputObject_1;\n    }\n\n    if (type instanceof graphql_1.GraphQLScalarType) {\n      return callMethod('visitScalar', type);\n    }\n\n    if (type instanceof graphql_1.GraphQLUnionType) {\n      return callMethod('visitUnion', type);\n    }\n\n    if (type instanceof graphql_1.GraphQLEnumType) {\n      var newEnum_1 = callMethod('visitEnum', type);\n\n      if (newEnum_1) {\n        updateEachKey(newEnum_1.getValues(), function (value) {\n          return callMethod('visitEnumValue', value, {\n            enumType: newEnum_1\n          });\n        });\n      }\n\n      return newEnum_1;\n    }\n\n    throw new Error(\"Unexpected schema type: \" + type);\n  }\n\n  function visitFields(type) {\n    updateEachKey(type.getFields(), function (field) {\n      // It would be nice if we could call visit(field) recursively here, but\n      // GraphQLField is merely a type, not a value that can be detected using\n      // an instanceof check, so we have to visit the fields in this lexical\n      // context, so that TypeScript can validate the call to\n      // visitFieldDefinition.\n      var newField = callMethod('visitFieldDefinition', field, {\n        // While any field visitor needs a reference to the field object, some\n        // field visitors may also need to know the enclosing (parent) type,\n        // perhaps to determine if the parent is a GraphQLObjectType or a\n        // GraphQLInterfaceType. To obtain a reference to the parent, a\n        // visitor method can have a second parameter, which will be an object\n        // with an .objectType property referring to the parent.\n        objectType: type\n      });\n\n      if (newField && newField.args) {\n        updateEachKey(newField.args, function (arg) {\n          return callMethod('visitArgumentDefinition', arg, {\n            // Like visitFieldDefinition, visitArgumentDefinition takes a\n            // second parameter that provides additional context, namely the\n            // parent .field and grandparent .objectType. Remember that the\n            // current GraphQLSchema is always available via this.schema.\n            field: newField,\n            objectType: type\n          });\n        });\n      }\n\n      return newField;\n    });\n  }\n\n  visit(schema); // Return the original schema for convenience, even though it cannot have\n  // been replaced or removed by the code above.\n\n  return schema;\n}\n\nexports.visitSchema = visitSchema; // Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n\nfunction healSchema(schema) {\n  heal(schema);\n  return schema;\n\n  function heal(type) {\n    if (type instanceof graphql_1.GraphQLSchema) {\n      var originalTypeMap_1 = type.getTypeMap();\n      var actualNamedTypeMap_1 = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in\n      // schema.getTypeMap() have changed, the keys of the type map need to\n      // be updated accordingly.\n\n      each(originalTypeMap_1, function (namedType, typeName) {\n        if (typeName.startsWith('__')) {\n          return;\n        }\n\n        var actualName = namedType.name;\n\n        if (actualName.startsWith('__')) {\n          return;\n        }\n\n        if (hasOwn.call(actualNamedTypeMap_1, actualName)) {\n          throw new Error(\"Duplicate schema type name \" + actualName);\n        }\n\n        actualNamedTypeMap_1[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its\n        // original name (which might be different from actualName), so that\n        // references by that name can be healed.\n      }); // Now add back every named type by its actual name.\n\n      each(actualNamedTypeMap_1, function (namedType, typeName) {\n        originalTypeMap_1[typeName] = namedType;\n      }); // Directive declaration argument types can refer to named types.\n\n      each(type.getDirectives(), function (decl) {\n        if (decl.args) {\n          each(decl.args, function (arg) {\n            arg.type = healType(arg.type);\n          });\n        }\n      });\n      each(originalTypeMap_1, function (namedType, typeName) {\n        if (!typeName.startsWith('__')) {\n          heal(namedType);\n        }\n      });\n      updateEachKey(originalTypeMap_1, function (namedType, typeName) {\n        // Dangling references to renamed types should remain in the schema\n        // during healing, but must be removed now, so that the following\n        // invariant holds for all names: schema.getType(name).name === name\n        if (!typeName.startsWith('__') && !hasOwn.call(actualNamedTypeMap_1, typeName)) {\n          return null;\n        }\n      });\n    } else if (type instanceof graphql_1.GraphQLObjectType) {\n      healFields(type);\n      each(type.getInterfaces(), function (iface) {\n        return heal(iface);\n      });\n    } else if (type instanceof graphql_1.GraphQLInterfaceType) {\n      healFields(type);\n    } else if (type instanceof graphql_1.GraphQLInputObjectType) {\n      each(type.getFields(), function (field) {\n        field.type = healType(field.type);\n      });\n    } else if (type instanceof graphql_1.GraphQLScalarType) {// Nothing to do.\n    } else if (type instanceof graphql_1.GraphQLUnionType) {\n      updateEachKey(type.getTypes(), function (t) {\n        return healType(t);\n      });\n    } else if (type instanceof graphql_1.GraphQLEnumType) {// Nothing to do.\n    } else {\n      throw new Error(\"Unexpected schema type: \" + type);\n    }\n  }\n\n  function healFields(type) {\n    each(type.getFields(), function (field) {\n      field.type = healType(field.type);\n\n      if (field.args) {\n        each(field.args, function (arg) {\n          arg.type = healType(arg.type);\n        });\n      }\n    });\n  }\n\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if (type instanceof graphql_1.GraphQLList) {\n      type = new graphql_1.GraphQLList(healType(type.ofType));\n    } else if (type instanceof graphql_1.GraphQLNonNull) {\n      type = new graphql_1.GraphQLNonNull(healType(type.ofType));\n    } else if (graphql_1.isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      var namedType = type;\n      var officialType = schema.getType(namedType.name);\n\n      if (officialType && namedType !== officialType) {\n        return officialType;\n      }\n    }\n\n    return type;\n  }\n}\n\nexports.healSchema = healSchema; // This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\n\nvar SchemaDirectiveVisitor =\n/** @class */\nfunction (_super) {\n  __extends(SchemaDirectiveVisitor, _super); // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n  // subclasses (not instances) to visitSchemaDirectives.\n\n\n  function SchemaDirectiveVisitor(config) {\n    var _this = _super.call(this) || this;\n\n    _this.name = config.name;\n    _this.args = config.args;\n    _this.visitedType = config.visitedType;\n    _this.schema = config.schema;\n    _this.context = config.context;\n    return _this;\n  } // Override this method to return a custom GraphQLDirective (or modify one\n  // already present in the schema) to enforce argument types, provide default\n  // argument values, or specify schema locations where this @directive may\n  // appear. By default, any declaration found in the schema will be returned.\n\n\n  SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {\n    return schema.getDirective(directiveName);\n  }; // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n  // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n  // instance to visit the object decorated by the @directive.\n\n\n  SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, directiveVisitors, // Optional context object that will be available to all visitor instances\n  // via this.context. Defaults to an empty null-prototype object.\n  context) {\n    if (context === void 0) {\n      // Optional context object that will be available to all visitor instances\n      // via this.context. Defaults to an empty null-prototype object.\n      context = Object.create(null);\n    } // If the schema declares any directives for public consumption, record\n    // them here so that we can properly coerce arguments when/if we encounter\n    // an occurrence of the directive while walking the schema below.\n\n\n    var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors); // Map from directive names to lists of SchemaDirectiveVisitor instances\n    // created while visiting the schema.\n\n    var createdVisitors = Object.create(null);\n    Object.keys(directiveVisitors).forEach(function (directiveName) {\n      createdVisitors[directiveName] = [];\n    });\n\n    function visitorSelector(type, methodName) {\n      var visitors = [];\n      var directiveNodes = type.astNode && type.astNode.directives;\n\n      if (!directiveNodes) {\n        return visitors;\n      }\n\n      directiveNodes.forEach(function (directiveNode) {\n        var directiveName = directiveNode.name.value;\n\n        if (!hasOwn.call(directiveVisitors, directiveName)) {\n          return;\n        }\n\n        var visitorClass = directiveVisitors[directiveName]; // Avoid creating visitor objects if visitorClass does not override\n        // the visitor method named by methodName.\n\n        if (!visitorClass.implementsVisitorMethod(methodName)) {\n          return;\n        }\n\n        var decl = declaredDirectives[directiveName];\n        var args;\n\n        if (decl) {\n          // If this directive was explicitly declared, use the declared\n          // argument types (and any default values) to check, coerce, and/or\n          // supply default values for the given arguments.\n          args = values_1.getArgumentValues(decl, directiveNode);\n        } else {\n          // If this directive was not explicitly declared, just convert the\n          // argument nodes to their corresponding JavaScript values.\n          args = Object.create(null);\n          directiveNode.arguments.forEach(function (arg) {\n            args[arg.name.value] = valueFromASTUntyped(arg.value);\n          });\n        } // As foretold in comments near the top of the visitSchemaDirectives\n        // method, this is where instances of the SchemaDirectiveVisitor class\n        // get created and assigned names. While subclasses could override the\n        // constructor method, the constructor is marked as protected, so\n        // these are the only arguments that will ever be passed.\n\n\n        visitors.push(new visitorClass({\n          name: directiveName,\n          args: args,\n          visitedType: type,\n          schema: schema,\n          context: context\n        }));\n      });\n\n      if (visitors.length > 0) {\n        visitors.forEach(function (visitor) {\n          createdVisitors[visitor.name].push(visitor);\n        });\n      }\n\n      return visitors;\n    }\n\n    visitSchema(schema, visitorSelector); // Automatically update any references to named schema types replaced\n    // during the traversal, so implementors don't have to worry about that.\n\n    healSchema(schema);\n    return createdVisitors;\n  };\n\n  SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {\n    var declaredDirectives = Object.create(null);\n    each(schema.getDirectives(), function (decl) {\n      declaredDirectives[decl.name] = decl;\n    }); // If the visitor subclass overrides getDirectiveDeclaration, and it\n    // returns a non-null GraphQLDirective, use that instead of any directive\n    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n    // goes to the trouble of implementing getDirectiveDeclaration, it should\n    // be able to rely on that implementation.\n\n    each(directiveVisitors, function (visitorClass, directiveName) {\n      var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n\n      if (decl) {\n        declaredDirectives[directiveName] = decl;\n      }\n    });\n    each(declaredDirectives, function (decl, name) {\n      if (!hasOwn.call(directiveVisitors, name)) {\n        // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n        // multiple times with partial directiveVisitors maps, so it's not\n        // necessarily an error for directiveVisitors to be missing an\n        // implementation of a directive that was declared in the schema.\n        return;\n      }\n\n      var visitorClass = directiveVisitors[name];\n      each(decl.locations, function (loc) {\n        var visitorMethodName = directiveLocationToVisitorMethodName(loc);\n\n        if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) && !visitorClass.implementsVisitorMethod(visitorMethodName)) {\n          // While visitor subclasses may implement extra visitor methods,\n          // it's definitely a mistake if the GraphQLDirective declares itself\n          // applicable to certain schema locations, and the visitor subclass\n          // does not implement all the corresponding methods.\n          throw new Error(\"SchemaDirectiveVisitor for @\" + name + \" must implement \" + visitorMethodName + \" method\");\n        }\n      });\n    });\n    return declaredDirectives;\n  };\n\n  return SchemaDirectiveVisitor;\n}(SchemaVisitor);\n\nexports.SchemaDirectiveVisitor = SchemaDirectiveVisitor; // Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\n\nfunction directiveLocationToVisitorMethodName(loc) {\n  return 'visit' + loc.replace(/([^_]*)_?/g, function (wholeMatch, part) {\n    return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n  });\n}\n\nfunction each(arrayOrObject, callback) {\n  Object.keys(arrayOrObject).forEach(function (key) {\n    callback(arrayOrObject[key], key);\n  });\n} // A more powerful version of each that has the ability to replace or remove\n// array or object keys.\n\n\nfunction updateEachKey(arrayOrObject, // The callback can return nothing to leave the key untouched, null to remove\n// the key from the array or object, or a non-null V to replace the value.\ncallback) {\n  var deletedCount = 0;\n  Object.keys(arrayOrObject).forEach(function (key) {\n    var result = callback(arrayOrObject[key], key);\n\n    if (typeof result === 'undefined') {\n      return;\n    }\n\n    if (result === null) {\n      delete arrayOrObject[key];\n      deletedCount++;\n      return;\n    }\n\n    arrayOrObject[key] = result;\n  });\n\n  if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\n    // Remove any holes from the array due to deleted elements.\n    arrayOrObject.splice(0).forEach(function (elem) {\n      arrayOrObject.push(elem);\n    });\n  }\n} // Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\n\n\nfunction valueFromASTUntyped(valueNode) {\n  switch (valueNode.kind) {\n    case graphql_1.Kind.NULL:\n      return null;\n\n    case graphql_1.Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case graphql_1.Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case graphql_1.Kind.STRING:\n    case graphql_1.Kind.ENUM:\n    case graphql_1.Kind.BOOLEAN:\n      return valueNode.value;\n\n    case graphql_1.Kind.LIST:\n      return valueNode.values.map(valueFromASTUntyped);\n\n    case graphql_1.Kind.OBJECT:\n      var obj_1 = Object.create(null);\n      valueNode.fields.forEach(function (field) {\n        obj_1[field.name.value] = valueFromASTUntyped(field.value);\n      });\n      return obj_1;\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error('Unexpected value kind: ' + valueNode.kind);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}