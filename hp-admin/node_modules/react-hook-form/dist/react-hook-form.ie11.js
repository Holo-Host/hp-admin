'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

var isCheckBoxInput = (function (type) { return type === 'checkbox'; });

function attachEventListeners(_a) {
    var field = _a.field, validateAndStateUpdate = _a.validateAndStateUpdate, isRadio = _a.isRadio;
    var ref = field.ref;
    if (!ref.addEventListener)
        return;
    ref.addEventListener(isCheckBoxInput(ref.type) || isRadio ? 'change' : 'input', validateAndStateUpdate);
    ref.addEventListener('blur', validateAndStateUpdate);
}

var isUndefined = (function (val) { return val === undefined; });

var isNullOrUndefined = (function (value) {
    return value === null || isUndefined(value);
});

var isObject = (function (value) {
    return !isNullOrUndefined(value) &&
        !Array.isArray(value) &&
        typeof value === 'object';
});

var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var reIsUint = /^(?:0|[1-9]\d*)$/;
var isArray = Array.isArray;
function isIndex(value) {
    return reIsUint.test(value) && value > -1;
}
function isKey(value) {
    if (isArray(value))
        return false;
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value);
}
var stringToPath = function (string) {
    var result = [];
    string.replace(rePropName, function (match, number, quote, string) {
        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
};
function set(object, path, value) {
    var tempPath = isKey(path) ? [path] : stringToPath(path);
    var index = -1;
    var length = tempPath.length;
    var lastIndex = length - 1;
    while (++index < length) {
        var key = tempPath[index];
        var newValue = value;
        if (index !== lastIndex) {
            var objValue = object[key];
            newValue =
                isObject(objValue) || isArray(objValue)
                    ? objValue
                    : isIndex(tempPath[index + 1])
                        ? []
                        : {};
        }
        object[key] = newValue;
        object = object[key];
    }
    return object;
}

var combineFieldValues = (function (data) {
    return Object.entries(data).reduce(function (previous, _a) {
        var _b;
        var _c = __read(_a, 2), key = _c[0], value = _c[1];
        if (key.match(/\[\d+\]/gi) || key.indexOf('.')) {
            set(previous, key, value);
            return previous;
        }
        return __assign(__assign({}, previous), (_b = {}, _b[key] = value, _b));
    }, {});
});

var removeAllEventListeners = (function (ref, validateWithStateUpdate) {
    if (!ref.removeEventListener)
        return;
    ref.removeEventListener('input', validateWithStateUpdate);
    ref.removeEventListener('change', validateWithStateUpdate);
    ref.removeEventListener('blur', validateWithStateUpdate);
});

var isRadioInput = (function (type) { return type === 'radio'; });

function isDetached(element) {
    if (!element)
        return true;
    if (!(element instanceof HTMLElement) ||
        element.nodeType === Node.DOCUMENT_NODE)
        return false;
    return isDetached(element.parentNode);
}

function findRemovedFieldAndRemoveListener(fields, validateWithStateUpdate, field, forceDelete) {
    if (validateWithStateUpdate === void 0) { validateWithStateUpdate = function () { }; }
    if (forceDelete === void 0) { forceDelete = false; }
    if (!field)
        return;
    var ref = field.ref, mutationWatcher = field.mutationWatcher, options = field.options;
    if (!ref || !ref.type)
        return;
    var name = ref.name, type = ref.type;
    if (isRadioInput(type) && options) {
        options.forEach(function (_a, index) {
            var ref = _a.ref;
            if (options[index] && isDetached(ref) || forceDelete) {
                removeAllEventListeners(options[index], validateWithStateUpdate);
                (options[index].mutationWatcher || { disconnect: function () { } }).disconnect();
                options.splice(index, 1);
            }
        });
        if (!options.length)
            delete fields[name];
    }
    else if (isDetached(ref) || forceDelete) {
        removeAllEventListeners(ref, validateWithStateUpdate);
        if (mutationWatcher)
            mutationWatcher.disconnect();
        delete fields[name];
    }
}

var defaultReturn = {
    isValid: false,
    value: '',
};
function getRadioValue(options) {
    return options && Array.isArray(options)
        ? options.reduce(function (previous, _a) {
            var _b = _a.ref, checked = _b.checked, value = _b.value;
            return checked
                ? {
                    isValid: true,
                    value: value,
                }
                : previous;
        }, defaultReturn)
        : defaultReturn;
}

var getMultipleSelectValue = (function (options) {
    return __spread(options).filter(function (_a) {
        var selected = _a.selected;
        return selected;
    }).map(function (_a) {
        var value = _a.value;
        return value;
    });
});

var isMultipleSelect = (function (type) { return type === 'select-multiple'; });

function getFieldValue(fields, ref) {
    var type = ref.type, name = ref.name, options = ref.options, checked = ref.checked, value = ref.value;
    if (isRadioInput(type)) {
        var field = fields[name];
        return field ? getRadioValue(field.options).value : '';
    }
    if (isMultipleSelect(type))
        return getMultipleSelectValue(options);
    if (isCheckBoxInput(type)) {
        if (checked) {
            return ref.attributes && ref.attributes.value
                ? isUndefined(value) || value === ''
                    ? true
                    : value
                : true;
        }
        return false;
    }
    return value;
}

var isString = (function (value) { return typeof value === 'string'; });

function getFieldsValue(fields, fieldName) {
    return Object.values(fields).reduce(function (previous, _a) {
        var ref = _a.ref, name = _a.ref.name;
        var value = getFieldValue(fields, ref);
        if (isString(fieldName))
            return name === fieldName ? value : previous;
        if (!fieldName) {
            previous[name] = value;
        }
        else if (Array.isArray(fieldName) && fieldName.includes(name)) {
            previous[name] = value;
        }
        return previous;
    }, {});
}

var isEmptyObject = (function (value) {
    return isObject(value) && Object.keys(value).length === 0;
});

var isSameError = (function (error, type, message) { return isObject(error) && (error.type === type && error.message === message); });

function shouldUpdateWithError(_a) {
    var errors = _a.errors, name = _a.name, error = _a.error, isValidateDisabled = _a.isValidateDisabled;
    if (isValidateDisabled ||
        (isEmptyObject(error) && isEmptyObject(errors)) ||
        (errors[name] && errors[name].isManual)) {
        return false;
    }
    if ((isEmptyObject(errors) && !isEmptyObject(error)) ||
        (isEmptyObject(error) && errors[name]) ||
        !errors[name]) {
        return true;
    }
    return (errors[name] &&
        error[name] &&
        !isSameError(errors[name], error[name].type, error[name].message));
}

var isRegex = (function (value) { return value instanceof RegExp; });

var getValueAndMessage = (function (validationData) { return ({
    value: isObject(validationData) &&
        !isRegex(validationData) &&
        !isNullOrUndefined(validationData.value)
        ? validationData.value
        : validationData,
    message: isObject(validationData) &&
        !(validationData instanceof RegExp) &&
        validationData.message
        ? validationData.message
        : '',
}); });

var displayNativeError = (function (nativeValidation, ref, message) {
    if (nativeValidation && isString(message))
        ref.setCustomValidity(message);
});

var DATE_INPUTS = [
    'date',
    'time',
    'month',
    'datetime',
    'datetime-local',
    'week',
];
var STRING_INPUTS = [
    'text',
    'email',
    'password',
    'search',
    'tel',
    'url',
    'textarea',
];
var VALIDATION_MODE = {
    onBlur: 'onBlur',
    onChange: 'onChange',
    onSubmit: 'onSubmit',
};

var isFunction = (function (value) {
    return typeof value === 'function';
});

var isBoolean = (function (value) { return typeof value === 'boolean'; });

var validateField = (function (_a, fields, nativeValidation) {
    var ref = _a.ref, _b = _a.ref, type = _b.type, value = _b.value, name = _b.name, checked = _b.checked, options = _a.options, required = _a.required, maxLength = _a.maxLength, minLength = _a.minLength, min = _a.min, max = _a.max, pattern = _a.pattern, validate = _a.validate;
    return __awaiter(void 0, void 0, void 0, function () {
        var error, isRadio, isCheckBox, isSelectOrInput, nativeError, isStringInput, exceedMax, exceedMin, valueNumber, _c, maxValue, maxMessage, _d, minValue, minMessage, message, _e, maxLengthValue, maxLengthMessage, _f, minLengthValue, minLengthMessage, inputLength, exceedMax, exceedMin, message, _g, patternValue, patternMessage, fieldValue_1, validateRef_1, result, validationResult;
        return __generator(this, function (_h) {
            switch (_h.label) {
                case 0:
                    error = {};
                    isRadio = isRadioInput(type);
                    isCheckBox = isCheckBoxInput(type);
                    isSelectOrInput = !isCheckBox && !isRadio;
                    nativeError = displayNativeError.bind(null, nativeValidation, ref);
                    isStringInput = STRING_INPUTS.includes(type) || isString(value);
                    if (required &&
                        ((isCheckBox && !checked) ||
                            (isSelectOrInput && value === '') ||
                            (isRadio && !getRadioValue(fields[name].options).isValid) ||
                            (!type && !value))) {
                        error[name] = {
                            type: 'required',
                            message: isString(required) ? required : '',
                            ref: isRadio ? (fields[name].options || [{ ref: '' }])[0].ref : ref,
                        };
                        nativeError(required);
                        return [2 /*return*/, error];
                    }
                    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {
                        exceedMax = void 0;
                        exceedMin = void 0;
                        valueNumber = parseFloat(value);
                        _c = getValueAndMessage(max), maxValue = _c.value, maxMessage = _c.message;
                        _d = getValueAndMessage(min), minValue = _d.value, minMessage = _d.message;
                        if (type === 'number' || !isNaN(value)) {
                            exceedMax = !isNullOrUndefined(maxValue) && valueNumber > maxValue;
                            exceedMin = !isNullOrUndefined(minValue) && valueNumber < minValue;
                        }
                        else if (DATE_INPUTS.includes(type) || type === undefined) {
                            if (isString(maxValue))
                                exceedMax = maxValue && new Date(value) > new Date(maxValue);
                            if (isString(minValue))
                                exceedMin = minValue && new Date(value) < new Date(minValue);
                        }
                        if (exceedMax || exceedMin) {
                            message = exceedMax ? maxMessage : minMessage;
                            error[name] = {
                                type: exceedMax ? 'max' : 'min',
                                message: message,
                                ref: ref,
                            };
                            nativeError(message);
                            return [2 /*return*/, error];
                        }
                    }
                    if ((maxLength || minLength) && isStringInput) {
                        _e = getValueAndMessage(maxLength), maxLengthValue = _e.value, maxLengthMessage = _e.message;
                        _f = getValueAndMessage(minLength), minLengthValue = _f.value, minLengthMessage = _f.message;
                        inputLength = value.toString().length;
                        exceedMax = maxLength && inputLength > maxLengthValue;
                        exceedMin = inputLength && minLength && inputLength < minLengthValue;
                        message = exceedMax ? maxLengthMessage : minLengthMessage;
                        if (exceedMax || exceedMin) {
                            error[name] = {
                                type: exceedMax ? 'maxLength' : 'minLength',
                                message: message,
                                ref: ref,
                            };
                            nativeError(message);
                            return [2 /*return*/, error];
                        }
                    }
                    if (pattern) {
                        _g = getValueAndMessage(pattern), patternValue = _g.value, patternMessage = _g.message;
                        if (isRegex(patternValue) && !patternValue.test(value)) {
                            error[name] = {
                                type: 'pattern',
                                message: patternMessage,
                                ref: ref,
                            };
                            nativeError(patternMessage);
                            return [2 /*return*/, error];
                        }
                    }
                    if (!validate) return [3 /*break*/, 4];
                    fieldValue_1 = getFieldValue(fields, ref);
                    validateRef_1 = isRadio && options ? options[0].ref : ref;
                    if (!isFunction(validate)) return [3 /*break*/, 2];
                    return [4 /*yield*/, validate(fieldValue_1)];
                case 1:
                    result = _h.sent();
                    if ((isString(result) && result) || (isBoolean(result) && !result)) {
                        error[name] = {
                            type: 'validate',
                            message: isString(result) ? result : '',
                            ref: validateRef_1,
                        };
                        nativeError(result);
                        return [2 /*return*/, error];
                    }
                    return [3 /*break*/, 4];
                case 2:
                    if (!isObject(validate)) return [3 /*break*/, 4];
                    return [4 /*yield*/, new Promise(function (resolve) {
                            var values = Object.entries(validate);
                            values.reduce(function (previous, _a, index) {
                                var _b = __read(_a, 2), key = _b[0], validate = _b[1];
                                return __awaiter(void 0, void 0, void 0, function () {
                                    var lastChild, result, message, data;
                                    return __generator(this, function (_c) {
                                        switch (_c.label) {
                                            case 0:
                                                lastChild = values.length - 1 === index;
                                                if (!isFunction(validate)) return [3 /*break*/, 2];
                                                return [4 /*yield*/, validate(fieldValue_1)];
                                            case 1:
                                                result = _c.sent();
                                                if (!isBoolean(result) || !result) {
                                                    message = isString(result) ? result : '';
                                                    data = {
                                                        type: key,
                                                        message: message,
                                                        ref: validateRef_1,
                                                    };
                                                    nativeError(message);
                                                    return [2 /*return*/, lastChild ? resolve(data) : data];
                                                }
                                                _c.label = 2;
                                            case 2: return [2 /*return*/, lastChild ? resolve(previous) : previous];
                                        }
                                    });
                                });
                            }, {});
                        })];
                case 3:
                    validationResult = _h.sent();
                    if (validationResult && !isEmptyObject(validationResult)) {
                        error[name] = __assign({ ref: validateRef_1 }, validationResult);
                        return [2 /*return*/, error];
                    }
                    _h.label = 4;
                case 4:
                    if (nativeValidation)
                        ref.setCustomValidity('');
                    return [2 /*return*/, error];
            }
        });
    });
});

function parseErrorSchema(error) {
    return error.inner.reduce(function (previous, _a) {
        var _b;
        var path = _a.path, message = _a.message, type = _a.type;
        return (__assign(__assign({}, previous), (_b = {}, _b[path] = { message: message, ref: {}, type: type }, _b)));
    }, {});
}
function validateWithSchema(validationSchema, validateWithSchema, data) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, e_1;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 2, , 3]);
                    _a = {};
                    return [4 /*yield*/, validationSchema.validate(data, validateWithSchema)];
                case 1: return [2 /*return*/, (_a.result = _b.sent(),
                        _a.fieldErrors = {},
                        _a)];
                case 2:
                    e_1 = _b.sent();
                    return [2 /*return*/, {
                            fieldErrors: parseErrorSchema(e_1),
                            result: {},
                        }];
                case 3: return [2 /*return*/];
            }
        });
    });
}

function attachNativeValidation(ref, rules) {
    Object.entries(rules).forEach(function (_a) {
        var _b = __read(_a, 2), key = _b[0], value = _b[1];
        if (key === 'pattern' && isRegex(value)) {
            ref[key] = value.source;
        }
        else {
            ref[key] = key === 'required' ? true : value;
        }
    });
}

function get(object, keys, defaultVal) {
    keys = Array.isArray(keys)
        ? keys
        : keys
            .replace(/\[/g, '.')
            .replace(/\]/g, '')
            .split('.');
    object = object[keys[0]];
    return object && keys.length > 1
        ? get(object, keys.slice(1), defaultVal)
        : isUndefined(object)
            ? defaultVal
            : object;
}

function getDefaultValue(defaultValues, name, defaultValue) {
    return isUndefined(defaultValues[name])
        ? get(defaultValues, name, defaultValue)
        : defaultValues[name];
}

function flatArray(list) {
    return list.reduce(function (a, b) { return a.concat(Array.isArray(b) ? flatArray(b) : b); }, []);
}

var getPath = function (path, values) {
    return Array.isArray(values)
        ? values.map(function (item, index) {
            var pathWithIndex = path + "[" + index + "]";
            if (Array.isArray(item)) {
                return getPath(pathWithIndex, item);
            }
            else if (isObject(item)) {
                return Object.entries(item).map(function (_a) {
                    var _b = __read(_a, 2), key = _b[0], objectValue = _b[1];
                    return isString(objectValue)
                        ? pathWithIndex + "." + key
                        : getPath(pathWithIndex + "." + key, objectValue);
                });
            }
            return pathWithIndex;
        })
        : Object.entries(values).map(function (_a) {
            var _b = __read(_a, 2), key = _b[0], objectValue = _b[1];
            return isString(objectValue) ? path + "." + key : getPath(path, objectValue);
        });
};
var getPath$1 = (function (parentPath, value) {
    return flatArray(getPath(parentPath, value));
});

var assignWatchFields = (function (fieldValues, fieldName, watchFields) {
    if (isEmptyObject(fieldValues) || isUndefined(fieldValues))
        return undefined;
    if (!isUndefined(fieldValues[fieldName])) {
        watchFields[fieldName] = true;
        return fieldValues[fieldName];
    }
    var values = get(combineFieldValues(fieldValues), fieldName);
    if (values !== undefined) {
        var result = getPath$1(fieldName, values);
        if (Array.isArray(result)) {
            result.forEach(function (name) {
                watchFields[name] = true;
            });
        }
    }
    return values;
});

var omitValidFields = (function (errorFields, validFieldNames) {
    return Object.entries(errorFields).reduce(function (previous, _a) {
        var _b;
        var _c = __read(_a, 2), name = _c[0], error = _c[1];
        return validFieldNames.some(function (validFieldName) { return validFieldName === name; })
            ? previous
            : __assign(__assign({}, previous), (_b = {}, _b[name] = error, _b));
    }, {});
});

var isArray$1 = (function (value) { return Array.isArray(value); });

function onDomRemove(element, onDetachCallback) {
    var observer = new MutationObserver(function () {
        if (isDetached(element)) {
            observer.disconnect();
            onDetachCallback();
        }
    });
    observer.observe(window.document, {
        childList: true,
        subtree: true,
    });
    return observer;
}

var modeChecker = (function (mode) { return ({
    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
    isOnBlur: mode === VALIDATION_MODE.onBlur,
    isOnChange: mode === VALIDATION_MODE.onChange,
}); });

function useForm(_a) {
    var _this = this;
    var _b = _a === void 0 ? {} : _a, _c = _b.mode, mode = _c === void 0 ? VALIDATION_MODE.onSubmit : _c, validationSchema = _b.validationSchema, _d = _b.defaultValues, defaultValues = _d === void 0 ? {} : _d, validationFields = _b.validationFields, nativeValidation = _b.nativeValidation, _e = _b.submitFocusError, submitFocusError = _e === void 0 ? true : _e, _f = _b.validationSchemaOption, validationSchemaOption = _f === void 0 ? { abortEarly: false } : _f;
    var fieldsRef = React.useRef({});
    var errorsRef = React.useRef({});
    var schemaErrorsRef = React.useRef({});
    var submitCountRef = React.useRef(0);
    var touchedFieldsRef = React.useRef(new Set());
    var watchFieldsRef = React.useRef({});
    var dirtyFieldsRef = React.useRef(new Set());
    var fieldsWithValidationRef = React.useRef(new Set());
    var validFieldsRef = React.useRef(new Set());
    var defaultValuesRef = React.useRef({});
    var isUnMount = React.useRef(false);
    var isWatchAllRef = React.useRef(false);
    var isSubmittingRef = React.useRef(false);
    var isSubmittedRef = React.useRef(false);
    var isDirtyRef = React.useRef(false);
    var isSchemaValidateTriggeredRef = React.useRef(false);
    var validationFieldsRef = React.useRef(validationFields);
    var validateAndStateUpdateRef = React.useRef();
    var _g = __read(React.useState({}), 2), reRenderForm = _g[1];
    var _h = React.useRef(modeChecker(mode)).current, isOnChange = _h.isOnChange, isOnBlur = _h.isOnBlur, isOnSubmit = _h.isOnSubmit;
    var validateWithSchemaCurry = React.useCallback(validateWithSchema.bind(null, validationSchema, validationSchemaOption), []);
    validationFieldsRef.current = validationFields;
    var combineErrorsRef = function (data) { return (__assign(__assign({}, errorsRef.current), data)); };
    var renderBaseOnError = React.useCallback(function (name, error, shouldRender) {
        if (shouldRender === void 0) { shouldRender = true; }
        if (errorsRef.current[name] && !error[name]) {
            delete errorsRef.current[name];
            if (fieldsWithValidationRef.current.has(name))
                validFieldsRef.current.add(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        if (error[name]) {
            validFieldsRef.current.delete(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        if (!isOnSubmit &&
            fieldsWithValidationRef.current.has(name) &&
            !validFieldsRef.current.has(name)) {
            validFieldsRef.current.add(name);
            if (shouldRender)
                reRenderForm({});
            return true;
        }
        return false;
    }, [isOnSubmit]);
    var setFieldValue = function (name, value) {
        var field = fieldsRef.current[name];
        if (!field)
            return;
        var ref = field.ref;
        var options = field.options;
        var type = ref.type;
        if (isRadioInput(type) && options) {
            options.forEach(function (_a) {
                var radioRef = _a.ref;
                return (radioRef.checked = radioRef.value === value);
            });
        }
        else if (isMultipleSelect(type)) {
            __spread(ref.options).forEach(function (selectRef) { return (selectRef.selected = value.includes(selectRef.value)); });
        }
        else {
            ref[isCheckBoxInput(type) ? 'checked' : 'value'] = value;
        }
    };
    var setDirty = function (name) {
        if (!fieldsRef.current[name])
            return false;
        var isDirty = defaultValuesRef.current[name] !==
            getFieldValue(fieldsRef.current, fieldsRef.current[name].ref);
        var isDirtyChanged = dirtyFieldsRef.current.has(name) !== isDirty;
        if (isDirty) {
            dirtyFieldsRef.current.add(name);
        }
        else {
            dirtyFieldsRef.current.delete(name);
        }
        isDirtyRef.current = !!dirtyFieldsRef.current.size;
        return isDirtyChanged;
    };
    var setValueInternal = React.useCallback(function (name, value) {
        setFieldValue(name, value);
        touchedFieldsRef.current.add(name);
        setDirty(name);
        reRenderForm({});
    }, []);
    var executeValidation = React.useCallback(function (_a, shouldRender) {
        var name = _a.name, value = _a.value;
        if (shouldRender === void 0) { shouldRender = true; }
        return __awaiter(_this, void 0, void 0, function () {
            var field, error;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        field = fieldsRef.current[name];
                        if (!field)
                            return [2 /*return*/, false];
                        if (value !== undefined)
                            setValueInternal(name, value);
                        return [4 /*yield*/, validateField(field, fieldsRef.current)];
                    case 1:
                        error = _b.sent();
                        errorsRef.current = combineErrorsRef(error);
                        renderBaseOnError(name, error, shouldRender);
                        return [2 /*return*/, isEmptyObject(error)];
                }
            });
        });
    }, [renderBaseOnError, setValueInternal]);
    var executeSchemaValidation = React.useCallback(function (payload) { return __awaiter(_this, void 0, void 0, function () {
        var fieldErrors, names, validFieldNames;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, validateWithSchemaCurry(combineFieldValues(getFieldsValue(fieldsRef.current)))];
                case 1:
                    fieldErrors = (_a.sent()).fieldErrors;
                    names = isArray$1(payload)
                        ? payload.map(function (_a) {
                            var name = _a.name;
                            return name;
                        })
                        : [payload.name];
                    validFieldNames = names.filter(function (name) { return !fieldErrors[name]; });
                    schemaErrorsRef.current = fieldErrors;
                    errorsRef.current = omitValidFields(combineErrorsRef(Object.entries(fieldErrors)
                        .filter(function (_a) {
                        var _b = __read(_a, 1), key = _b[0];
                        return names.includes(key);
                    })
                        .reduce(function (previous, _a) {
                        var _b;
                        var _c = __read(_a, 2), name = _c[0], error = _c[1];
                        return (__assign(__assign({}, previous), (_b = {}, _b[name] = error, _b)));
                    }, {})), validFieldNames);
                    isSchemaValidateTriggeredRef.current = true;
                    reRenderForm({});
                    return [2 /*return*/, isEmptyObject(errorsRef.current)];
            }
        });
    }); }, [validateWithSchemaCurry]);
    var triggerValidation = React.useCallback(function (payload) { return __awaiter(_this, void 0, void 0, function () {
        var fields, result;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fields = payload || Object.keys(fieldsRef.current).map(function (name) { return ({ name: name }); });
                    if (validationSchema)
                        return [2 /*return*/, executeSchemaValidation(fields)];
                    if (!isArray$1(fields)) return [3 /*break*/, 2];
                    return [4 /*yield*/, Promise.all(fields.map(function (data) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, executeValidation(data, false)];
                                case 1: return [2 /*return*/, _a.sent()];
                            }
                        }); }); }))];
                case 1:
                    result = _a.sent();
                    reRenderForm({});
                    return [2 /*return*/, result.every(Boolean)];
                case 2: return [4 /*yield*/, executeValidation(fields)];
                case 3: return [2 /*return*/, _a.sent()];
            }
        });
    }); }, [executeSchemaValidation, executeValidation, validationSchema]);
    var setValue = React.useCallback(function (name, value, shouldValidate) {
        if (shouldValidate === void 0) { shouldValidate = false; }
        setValueInternal(name, value);
        if (shouldValidate)
            return triggerValidation({ name: name });
    }, [setValueInternal, triggerValidation]);
    validateAndStateUpdateRef.current = validateAndStateUpdateRef.current
        ? validateAndStateUpdateRef.current
        : function (_a) {
            var name = _a.target.name, type = _a.type;
            return __awaiter(_this, void 0, void 0, function () {
                var fields, errors, ref, isBlurEvent, isValidateDisabled, shouldUpdateValidateMode, shouldUpdateState, fieldErrors, error, shouldUpdate, error, shouldUpdate;
                var _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            if (isArray$1(validationFieldsRef.current) &&
                                !validationFieldsRef.current.includes(name))
                                return [2 /*return*/];
                            fields = fieldsRef.current;
                            errors = errorsRef.current;
                            ref = fields[name];
                            if (!ref)
                                return [2 /*return*/];
                            isBlurEvent = type === 'blur';
                            isValidateDisabled = !isSubmittedRef.current && isOnSubmit;
                            shouldUpdateValidateMode = isOnChange || (isOnBlur && isBlurEvent) || errors[name];
                            shouldUpdateState = isWatchAllRef.current || watchFieldsRef.current[name];
                            if (setDirty(name)) {
                                shouldUpdateState = true;
                            }
                            if (!touchedFieldsRef.current.has(name)) {
                                touchedFieldsRef.current.add(name);
                                shouldUpdateState = true;
                            }
                            if (isValidateDisabled)
                                return [2 /*return*/, shouldUpdateState ? reRenderForm({}) : undefined];
                            if (!validationSchema) return [3 /*break*/, 2];
                            return [4 /*yield*/, validateWithSchemaCurry(combineFieldValues(getFieldsValue(fields)))];
                        case 1:
                            fieldErrors = (_c.sent()).fieldErrors;
                            schemaErrorsRef.current = fieldErrors;
                            isSchemaValidateTriggeredRef.current = true;
                            error = fieldErrors[name];
                            shouldUpdate = ((!error && errors[name]) || error) &&
                                (shouldUpdateValidateMode || isSubmittedRef.current);
                            if (shouldUpdate) {
                                errorsRef.current = __assign(__assign({}, errors), (_b = {}, _b[name] = error, _b));
                                if (!error)
                                    delete errorsRef.current[name];
                                return [2 /*return*/, reRenderForm({})];
                            }
                            return [3 /*break*/, 4];
                        case 2: return [4 /*yield*/, validateField(ref, fields, nativeValidation)];
                        case 3:
                            error = _c.sent();
                            shouldUpdate = shouldUpdateWithError({
                                errors: errors,
                                error: error,
                                isValidateDisabled: isValidateDisabled,
                                name: name,
                            });
                            if (shouldUpdate || shouldUpdateValidateMode) {
                                errorsRef.current = combineErrorsRef(error);
                                if (renderBaseOnError(name, error))
                                    return [2 /*return*/];
                            }
                            _c.label = 4;
                        case 4:
                            if (shouldUpdateState)
                                reRenderForm({});
                            return [2 /*return*/];
                    }
                });
            });
        };
    var resetFieldRef = function (name) {
        delete watchFieldsRef.current[name];
        delete errorsRef.current[name];
        delete fieldsRef.current[name];
        delete defaultValuesRef.current[name];
        [
            touchedFieldsRef,
            dirtyFieldsRef,
            fieldsWithValidationRef,
            validFieldsRef,
        ].forEach(function (data) { return data.current.delete(name); });
    };
    var removeEventListenerAndRef = React.useCallback(function (field, forceDelete) {
        if (!field)
            return;
        findRemovedFieldAndRemoveListener(fieldsRef.current, validateAndStateUpdateRef.current, field, forceDelete);
        resetFieldRef(field.ref.name);
    }, []);
    function clearError(name) {
        if (isString(name)) {
            delete errorsRef.current[name];
        }
        else if (isArray$1(name)) {
            name.forEach(function (fieldName) { return delete errorsRef.current[fieldName]; });
        }
        else {
            errorsRef.current = {};
        }
        reRenderForm({});
    }
    var setError = function (name, type, message, ref) {
        var errors = errorsRef.current;
        var error = errors[name];
        if (!isSameError(error, type, message)) {
            errors[name] = {
                type: type,
                message: message,
                ref: ref,
                isManual: true,
            };
            reRenderForm({});
        }
    };
    function watch(fieldNames, defaultValue) {
        var fieldValues = getFieldsValue(fieldsRef.current);
        var watchFields = watchFieldsRef.current;
        if (isString(fieldNames)) {
            var value = assignWatchFields(fieldValues, fieldNames, watchFields);
            return !isUndefined(value)
                ? value
                : isUndefined(defaultValue)
                    ? getDefaultValue(defaultValues, fieldNames)
                    : defaultValue;
        }
        if (isArray$1(fieldNames)) {
            return fieldNames.reduce(function (previous, name) {
                var _a;
                var value = getDefaultValue(defaultValues, name);
                if (isEmptyObject(fieldsRef.current) &&
                    !isUndefined(defaultValue) &&
                    !isString(defaultValue)) {
                    value = defaultValue[name];
                }
                else {
                    var tempValue = assignWatchFields(fieldValues, name, watchFields);
                    if (!isUndefined(tempValue))
                        value = tempValue;
                }
                return __assign(__assign({}, previous), (_a = {}, _a[name] = value, _a));
            }, {});
        }
        isWatchAllRef.current = true;
        return ((!isEmptyObject(fieldValues) && fieldValues) ||
            defaultValue ||
            defaultValues);
    }
    function __registerIntoFieldsRef(ref, validateOptions) {
        if (validateOptions === void 0) { validateOptions = {}; }
        if (!ref.name)
            return console.warn('Miss ref', ref);
        var name = ref.name, type = ref.type, value = ref.value;
        var required = validateOptions.required, validate = validateOptions.validate;
        var fieldAttributes = __assign({ ref: ref }, validateOptions);
        var fields = fieldsRef.current;
        var isRadio = isRadioInput(type);
        var currentField = fields[name];
        var isRegistered = isRadio
            ? currentField &&
                isArray$1(currentField.options) &&
                currentField.options.find(function (_a) {
                    var ref = _a.ref;
                    return value === ref.value;
                })
            : currentField;
        if (isRegistered)
            return;
        if (!type) {
            fields[name] = fieldAttributes;
        }
        else {
            var mutationWatcher = onDomRemove(ref, function () {
                return removeEventListenerAndRef(fieldAttributes);
            });
            if (isRadio) {
                if (!currentField)
                    fields[name] = {
                        options: [],
                        required: required,
                        validate: validate,
                        ref: { type: 'radio', name: name },
                    };
                if (validate)
                    fields[name].validate = validate;
                fields[name].options.push(__assign(__assign({}, fieldAttributes), { mutationWatcher: mutationWatcher }));
            }
            else {
                fields[name] = __assign(__assign({}, fieldAttributes), { mutationWatcher: mutationWatcher });
            }
        }
        if (!isEmptyObject(defaultValues)) {
            var defaultValue = getDefaultValue(defaultValues, name);
            if (!isUndefined(defaultValue))
                setFieldValue(name, defaultValue);
        }
        if (!isOnSubmit && validateOptions && !isEmptyObject(validateOptions)) {
            fieldsWithValidationRef.current.add(name);
            if (validationSchema) {
                isSchemaValidateTriggeredRef.current = true;
                validateWithSchemaCurry(combineFieldValues(getFieldsValue(fields))).then(function (_a) {
                    var fieldErrors = _a.fieldErrors;
                    schemaErrorsRef.current = fieldErrors;
                    if (isEmptyObject(schemaErrorsRef.current))
                        reRenderForm({});
                });
            }
            else {
                validateField(fields[name], fields).then(function (error) {
                    if (isEmptyObject(error))
                        validFieldsRef.current.add(name);
                    if (validFieldsRef.current.size === fieldsWithValidationRef.current.size)
                        reRenderForm({});
                });
            }
        }
        if (!defaultValuesRef.current[name])
            defaultValuesRef.current[name] = getFieldValue(fields, fields[name].ref);
        if (!type)
            return;
        var field = isRadio
            ? fields[name].options[fields[name].options.length - 1]
            : fields[name];
        if (nativeValidation && validateOptions) {
            attachNativeValidation(ref, validateOptions);
        }
        else {
            attachEventListeners({
                field: field,
                isRadio: isRadio,
                validateAndStateUpdate: validateAndStateUpdateRef.current,
            });
        }
    }
    function register(refOrValidateRule, validationOptions) {
        if (typeof window === 'undefined' || !refOrValidateRule)
            return;
        if (isObject(refOrValidateRule) &&
            (validationOptions || 'name' in refOrValidateRule)) {
            __registerIntoFieldsRef(refOrValidateRule, validationOptions);
            return;
        }
        return function (ref) {
            return ref && __registerIntoFieldsRef(ref, refOrValidateRule);
        };
    }
    function unregister(names) {
        if (isEmptyObject(fieldsRef.current))
            return;
        (isArray$1(names) ? names : [names]).forEach(function (fieldName) {
            return removeEventListenerAndRef(fieldsRef.current[fieldName], true);
        });
    }
    var handleSubmit = function (callback) { return function (e) { return __awaiter(_this, void 0, void 0, function () {
        var fieldErrors, fieldValues, firstFocusError, fields, fieldsToValidate, output, _a, errors, values;
        var _this = this;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (e) {
                        e.preventDefault();
                        e.persist();
                    }
                    firstFocusError = true;
                    fields = fieldsRef.current;
                    fieldsToValidate = validationFields
                        ? validationFields.map(function (name) { return fieldsRef.current[name]; })
                        : Object.values(fields);
                    isSubmittingRef.current = true;
                    reRenderForm({});
                    if (!validationSchema) return [3 /*break*/, 2];
                    fieldValues = getFieldsValue(fields);
                    return [4 /*yield*/, validateWithSchema(validationSchema, validationSchemaOption, combineFieldValues(fieldValues))];
                case 1:
                    output = _b.sent();
                    schemaErrorsRef.current = output.fieldErrors;
                    fieldErrors = output.fieldErrors;
                    fieldValues = output.result;
                    return [3 /*break*/, 4];
                case 2: return [4 /*yield*/, fieldsToValidate.reduce(function (previous, field) { return __awaiter(_this, void 0, void 0, function () {
                        var resolvedPrevious, ref, _a, name, focus, fieldError;
                        return __generator(this, function (_b) {
                            switch (_b.label) {
                                case 0:
                                    if (!field)
                                        return [2 /*return*/, previous];
                                    return [4 /*yield*/, previous];
                                case 1:
                                    resolvedPrevious = _b.sent();
                                    ref = field.ref, _a = field.ref, name = _a.name, focus = _a.focus;
                                    if (!fields[name])
                                        return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                                    return [4 /*yield*/, validateField(field, fields, nativeValidation)];
                                case 2:
                                    fieldError = _b.sent();
                                    if (fieldError[name]) {
                                        if (submitFocusError && firstFocusError && focus) {
                                            ref.focus();
                                            firstFocusError = false;
                                        }
                                        resolvedPrevious.errors = __assign(__assign({}, resolvedPrevious.errors), fieldError);
                                        return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                                    }
                                    resolvedPrevious.values[name] = getFieldValue(fields, ref);
                                    return [2 /*return*/, Promise.resolve(resolvedPrevious)];
                            }
                        });
                    }); }, Promise.resolve({
                        errors: {},
                        values: {},
                    }))];
                case 3:
                    _a = _b.sent(), errors = _a.errors, values = _a.values;
                    fieldErrors = errors;
                    fieldValues = values;
                    _b.label = 4;
                case 4:
                    if (!isEmptyObject(fieldErrors)) return [3 /*break*/, 6];
                    errorsRef.current = {};
                    return [4 /*yield*/, callback(combineFieldValues(fieldValues), e)];
                case 5:
                    _b.sent();
                    return [3 /*break*/, 7];
                case 6:
                    errorsRef.current = fieldErrors;
                    _b.label = 7;
                case 7:
                    if (isUnMount.current)
                        return [2 /*return*/];
                    isSubmittedRef.current = true;
                    submitCountRef.current += 1;
                    isSubmittingRef.current = false;
                    reRenderForm({});
                    return [2 /*return*/];
            }
        });
    }); }; };
    var resetRefs = function () {
        errorsRef.current = {};
        schemaErrorsRef.current = {};
        submitCountRef.current = 0;
        touchedFieldsRef.current = new Set();
        watchFieldsRef.current = {};
        dirtyFieldsRef.current = new Set();
        fieldsWithValidationRef.current = new Set();
        validFieldsRef.current = new Set();
        defaultValuesRef.current = {};
        isWatchAllRef.current = false;
        isSubmittedRef.current = false;
        isDirtyRef.current = false;
        isSchemaValidateTriggeredRef.current = false;
    };
    var reset = React.useCallback(function (values) {
        var e_1, _a;
        var fieldsKeyValue = Object.entries(fieldsRef.current);
        try {
            for (var fieldsKeyValue_1 = __values(fieldsKeyValue), fieldsKeyValue_1_1 = fieldsKeyValue_1.next(); !fieldsKeyValue_1_1.done; fieldsKeyValue_1_1 = fieldsKeyValue_1.next()) {
                var _b = __read(fieldsKeyValue_1_1.value, 2), value = _b[1];
                if (value && value.ref && value.ref.closest) {
                    try {
                        value.ref.closest('form').reset();
                        break;
                    }
                    catch (_c) { }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (fieldsKeyValue_1_1 && !fieldsKeyValue_1_1.done && (_a = fieldsKeyValue_1.return)) _a.call(fieldsKeyValue_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        resetRefs();
        if (values) {
            fieldsKeyValue.forEach(function (_a) {
                var _b = __read(_a, 1), key = _b[0];
                return setFieldValue(key, getDefaultValue(values, key, ''));
            });
        }
        reRenderForm({});
    }, []);
    var getValues = function (payload) {
        var fieldValues = getFieldsValue(fieldsRef.current);
        var output = payload && payload.nest ? combineFieldValues(fieldValues) : fieldValues;
        return isEmptyObject(output) ? defaultValues : output;
    };
    React.useEffect(function () { return function () {
        isUnMount.current = true;
        fieldsRef.current &&
            Object.values(fieldsRef.current).forEach(function (field) {
                return removeEventListenerAndRef(field, true);
            });
    }; }, [removeEventListenerAndRef]);
    return {
        register: React.useCallback(register, [__registerIntoFieldsRef]),
        unregister: React.useCallback(unregister, [
            unregister,
            removeEventListenerAndRef,
        ]),
        handleSubmit: handleSubmit,
        watch: watch,
        reset: reset,
        clearError: clearError,
        setError: setError,
        setValue: setValue,
        triggerValidation: triggerValidation,
        getValues: getValues,
        errors: validationFields
            ? Object.keys(errorsRef.current).reduce(function (previous, key) {
                var _a;
                return (__assign(__assign({}, previous), (validationFields.includes(key)
                    ? (_a = {}, _a[key] = errorsRef.current[key], _a) : null)));
            }, {})
            : errorsRef.current,
        formState: __assign({ dirty: isDirtyRef.current, isSubmitted: isSubmittedRef.current, submitCount: submitCountRef.current, touched: __spread(touchedFieldsRef.current), isSubmitting: isSubmittingRef.current }, (isOnSubmit
            ? {
                isValid: isEmptyObject(errorsRef.current),
            }
            : {
                isValid: validationSchema
                    ? isSchemaValidateTriggeredRef.current &&
                        isEmptyObject(schemaErrorsRef.current)
                    : fieldsWithValidationRef.current.size
                        ? !isEmptyObject(fieldsRef.current) &&
                            validFieldsRef.current.size >=
                                fieldsWithValidationRef.current.size
                        : !isEmptyObject(fieldsRef.current),
            })),
    };
}

var FormGlobalContext = React.createContext(null);
function useFormContext() {
    return React.useContext(FormGlobalContext);
}
function FormContext(props) {
    var children = props.children, rest = __rest(props, ["children"]);
    return (React.createElement(FormGlobalContext.Provider, { value: rest }, children));
}

exports.FormContext = FormContext;
exports.default = useForm;
exports.useFormContext = useFormContext;
